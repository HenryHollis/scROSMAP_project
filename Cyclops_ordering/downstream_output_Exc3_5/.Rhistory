seurat_obj@assays[["RNA"]]@features@.Data
seurat_obj@assays[["RNA"]]@features@.Data[,3]
seurat_obj@assays[["RNA"]]@features@.Data[,3] == so2@assays[["RNA"]]@features@.Data[,3]
all(seurat_obj@assays[["RNA"]]@features@.Data[,3] == so2@assays[["RNA"]]@features@.Data[,3])
so2 = seurat_obj
so2 <- NormalizeData(so2)
so2 <- FindVariableFeatures(so2)
View(so2)
so2 = seurat_obj
so2 <- NormalizeData(so2)
so2 <- FindVariableFeatures(so2)
View(so2)
so2@commands[["FindVariableFeatures.RNA"]]
?ScaleData
so2 = seurat_obj
so2@graphs
# so2 <- NormalizeData(so2)
# so2 <- FindVariableFeatures(so2)
# so2 <- ScaleData(so2)
# so2 <- RunPCA(so2,npcs = 30)
so2 <- FindNeighbors(so2, dims = 1:10, k.param = 20)
# so2 <- NormalizeData(so2)
# so2 <- FindVariableFeatures(so2)
# so2 <- ScaleData(so2)
# so2 <- RunPCA(so2,npcs = 30)
so2 <- FindNeighbors(so2, dims = 1:10, k.param = 20)
so2 <- FindClusters(so2, resolution = .3)
so2 <- FindClusters(so2, resolution = .3)
# Run UMAP
so2 <- RunUMAP(so2, dims = 1:30, n.neighbors = 20)
# Plot UMAP
DimPlot(so2, reduction = "umap")
DimPlot(seurat_obj, reduction = "umap")
seurat_obj@neighbors
seurat_obj@commands[["RunPCA.RNA"]]
so2 = seurat_obj
# so2 <- NormalizeData(so2)
# so2 <- FindVariableFeatures(so2)
# so2 <- ScaleData(so2)
# so2 <- RunPCA(so2,npcs = 30)
so2 <- FindNeighbors(so2, dims = 1:10, k.param = 20)
so2 <- FindClusters(so2, resolution = .3)
# Run UMAP
so2 <- RunUMAP(so2, dims = 1:30, n.neighbors = 20)
# Plot UMAP
DimPlot(so2, reduction = "pca")
DimPlot(seurat_obj, reduction = "pca")
?FindClusters
so2 = seurat_obj
# so2 <- NormalizeData(so2)
# so2 <- FindVariableFeatures(so2)
# so2 <- ScaleData(so2)
# so2 <- RunPCA(so2,npcs = 30)
so2 <- FindNeighbors(so2, dims = 1:10, k.param = 20)
?FindNeighbors
seurat_obj@commands[["FindNeighbors.RNA.integrated.rpca"]]
so2 = seurat_obj
# so2 <- NormalizeData(so2)
# so2 <- FindVariableFeatures(so2)
# so2 <- ScaleData(so2)
# so2 <- RunPCA(so2,npcs = 30)
so2 <- FindNeighbors(so2, dims = 1:30, k.param = 20, compute.SNN = T)
View(so2)
so2@commands[["RunPCA.RNA"]]@call.string
so2@commands[["RunPCA.RNA"]]@name
so2@graphs[["RNA_snn"]]
so2@graphs[["RNA_snn"]]@x
so2@graphs[["RNA_snn"]]@x == seurat_obj[["RNA_ssn"]]@x
so2@graphs[["RNA_snn"]]@x == seurat_obj@graphs[["RNA_ssn"]]@x
seurat_obj@graphs[["RNA_ssn"]]@x
seurat_obj@graphs[["RNA_snn"]]
seurat_obj@graphs[["RNA_snn"]]@x
seurat_obj@graphs[["RNA_snn"]]@x == so2@graphs[["RNA_snn"]]@x
seurat_obj@graphs[["RNA_snn"]]@x[1:100]
seurat_obj@graphs[["RNA_snn"]]@x[1:100, 1:100]
seurat_obj@graphs[["RNA_snn"]]@x[1:100]
so2 = seurat_obj
# so2 <- NormalizeData(so2)
# so2 <- FindVariableFeatures(so2)
# so2 <- ScaleData(so2)
# so2 <- RunPCA(so2,npcs = 30)
# so2 <- FindNeighbors(so2, dims = 1:30, k.param = 20, compute.SNN = T)
so2 <- FindClusters(so2, resolution = .3)
seurat_obj@commands[["RunUMAP.RNA.integrated.rpca"]]@params[["dims"]]
so2 <- RunUMAP(so2, dims = 1:30, n.neighbors = 20)
# Plot UMAP
DimPlot(so2, reduction = "pca")
DimPlot(seurat_obj, reduction = "pca")
t(so2, reduction = "umap")
DimPlot(so2, reduction = "umap")
DimPlot(seurat_obj, reduction = "umap")
so2$seurat_clusters == seurat_obj$seurat_clusters
all(so2$seurat_clusters == seurat_obj$seurat_clusters)
seurat_obj@commands[["RunUMAP.RNA.integrated.rpca"]]
seurat_obj@commands[["RunPCA.RNA"]]
seurat_obj@commands[["NormalizeData.RNA"]]
seurat_obj@commands[["RunPCA.RNA"]]
seurat_obj@commands[["FindNeighbors.RNA.integrated.rpca"]]
# Run UMAP
so2 <- RunUMAP(so2, dims = 1:30, n.neighbors = 20, reduction = "integrated.rpca")
DimPlot(so2, reduction = "umap")
DimPlot(seurat_obj, reduction = "umap")
seurat_obj@commands[["RunUMAP.RNA.integrated.rpca"]]@name
seurat_obj@commands[["RunUMAP.RNA.integrated.rpca"]]
so2 <- RunUMAP(so2, dims = 1:30, n.neighbors = 30, reduction = "integrated.rpca")
# Plot UMAP
DimPlot(so2, reduction = "umap")
DimPlot(seurat_obj, reduction = "umap")
?RunUMAP
so2 = seurat_obj
# so2 <- NormalizeData(so2)
# so2 <- FindVariableFeatures(so2)
# so2 <- ScaleData(so2)
# so2 <- RunPCA(so2,npcs = 30)
# so2 <- FindNeighbors(so2, dims = 1:30, k.param = 20, compute.SNN = T)
so2 <- FindClusters(so2, resolution = .3)
# Run UMAP
so2 <- RunUMAP(so2, dims = 1:30, n.neighbors = 30, reduction = "integrated.rpca")
# Plot UMAP
DimPlot(so2, reduction = "umap")
DimPlot(seurat_obj, reduction = "umap")
all(so2$seurat_clusters == seurat_obj$seurat_clusters)
?FindNeighbors
seurat_obj@commands[["FindNeighbors.RNA.integrated.rpca"]]
so_nocycle <- subset(seurat_obj, features = aryth_genes)
so_nocycle <- NormalizeData(so_nocycle)
so_nocycle <- FindVariableFeatures(so_nocycle)
so_nocycle <- ScaleData(so_nocycle)
so_nocycle <- RunPCA(so_nocycle)
so_nocycle <- FindNeighbors(so_nocycle, dims = 1:30, reduction = "integrated.rpca")
so_nocycle <- FindClusters(so_nocycle, resolution = 0.3)
# Run UMAP
so_nocycle <-  RunUMAP(so_nocycle, dims = 1:30, n.neighbors = 30, reduction = "integrated.rpca")
#
# so2$noCyclerClustering = Idents(so_nocycle)
#
# # Plot UMAP colored by the first clustering
# DimPlot(so2, reduction = "umap", group.by = "seurat_clusters") + ggtitle("First Clustering")
#
# # Plot UMAP colored by the second clustering
# DimPlot(so2, reduction = "umap", group.by = "noCyclerClustering") + ggtitle("Second Clustering")
seurat_obj$noCyclerClustering = Idents(so_nocycle)
DimPlot(seurat_obj, reduction = "umap") + ggtitle("With Cycling Genes Clustering")
DimPlot(seurat_obj, reduction = "umap", group.by = "noCyclerClustering") + ggtitle("No Cycling Genes (BH.q < 0.2) Clustering")
View(so_nocycle)
library(mclust)
ari = adjustedRandIndex(so2$seurat_clusters, so2$noCyclerClustering)
library(mclust)
ari = adjustedRandIndex(so_nocycle$seurat_clusters, seurat_obj$seurat_clusters)
print(ari)
so_nocycle <- subset(seurat_obj, features = aryth_genes)
View(so_nocycle)
so_nocycle <- NormalizeData(so_nocycle)
so_nocycle <- FindVariableFeatures(so_nocycle)
so_nocycle@assays[["RNA"]]@features@.Data %>% View()
so_nocycle <- ScaleData(so_nocycle)
so_nocycle@assays[["RNA"]]@features@.Data[,2] %>% table
so_nocycle@assays[["RNA"]]@features@.Data[,3] %>% table
so_nocycle@assays[["RNA"]]@features
so_nocycle@assays[["RNA"]]@features@.Data
so_nocycle <- RunPCA(so_nocycle)
# Subset the expression matrix to include only the genes of interest
expression_data <- seurat_obj@assays$RNA@counts[aryth_genes, ]
View(seurat_obj)
seurat_obj@assays[["RNA"]]@layers[["counts"]]
# Subset the expression matrix to include only the genes of interest
expression_data <- seurat_obj@assays$RNA@layers$counts[aryth_genes, ]
rownames(seurat_obj@assays$RNA@layers$counts)
rownames(seurat_obj@assays$RNA@layers$data)
rownames(seurat_obj@assays$RNA)
seurat_obj@assays$RNA@counts
seurat_obj@assays$RNA@layers$counts
rownames(seurat_obj@assays$RNA)
which(rownames(seurat_obj@assays$RNA) %in% aryth_genes)
length(which(rownames(seurat_obj@assays$RNA) %in% aryth_genes))
length(aryth_genes)
# Subset the expression matrix to include only the genes of interest
keep_genes_idx = which(rownames(seurat_obj@assays$RNA) %in% aryth_genes)
expression_data <- seurat_obj@assays$RNA@layers$counts[keep_genes_idx, ]
# Create a new Seurat object
so_nocycle <- CreateSeuratObject(counts = expression_data)
View(so_nocycle)
so_nocycle <- NormalizeData(so_nocycle)
so_nocycle <- FindVariableFeatures(so_nocycle)
so_nocycle <- ScaleData(so_nocycle)
so_nocycle@assays[["RNA"]]@features
so_nocycle@assays[["RNA"]]@features %>% View
?FindVariableFeatures
so_nocycle <- RunPCA(so_nocycle)
so_nocycle <- RunPCA(so_nocycle)
so_nocycle <- FindNeighbors(so_nocycle, dims = 1:30, reduction = "integrated.rpca")
?RunPCA
so2 = seurat_obj
#Normalization, through find neighbors is saved from seurat_obj, no need
# to recompute them:
# so2 <- NormalizeData(so2)
# so2 <- FindVariableFeatures(so2)
# so2 <- ScaleData(so2)
# so2 <- RunPCA(so2,npcs = 30)
# so2 <- FindNeighbors(so2, dims = 1:30, k.param = 20, compute.SNN = T)
so2 <- FindClusters(so2, resolution = .3)
# Run UMAP, Seeing if I can recreate Greengham's. Either way cluster assignment is the same.
so2 <- RunUMAP(so2, dims = 1:30, n.neighbors = 30, reduction = "integrated.rpca")
# Plot UMAP
DimPlot(so2, reduction = "umap")
DimPlot(seurat_obj, reduction = "umap")
all(so2$seurat_clusters == seurat_obj$seurat_clusters)
?FindNeighbors
so2 = seurat_obj
#Normalization, through RunPCA is saved from seurat_obj, no need
# to recompute them. Greenham uses "reduction = 'integrated.rpca'" for FindNeighbors. This is used when integrating multiple seurat objeccts, which I'm not doing so I will recompute the "findNeighbors." Therefore I don't expect our clustering to be exactly equal.
# so2 <- NormalizeData(so2)
# so2 <- FindVariableFeatures(so2)
# so2 <- ScaleData(so2)
# so2 <- RunPCA(so2,npcs = 30)
so2 <- FindNeighbors(so2, dims = 1:30, k.param = 20, compute.SNN = T)
so2 <- FindClusters(so2, resolution = .3)
# Run UMAP, Seeing if I can recreate Greengham's. Either way cluster assignment is the same.
so2 <- RunUMAP(so2, dims = 1:30, n.neighbors = 30, reduction = "integrated.rpca")
# Plot UMAP
DimPlot(so2, reduction = "umap")
DimPlot(seurat_obj, reduction = "umap")
all(so2$seurat_clusters == seurat_obj$seurat_clusters)
so2$seurat_clusters
seurat_obj$seurat_clusters
library(mclust)
ari = adjustedRandIndex(so2$seurat_clusters, seurat_obj$seurat_clusters)
print(ari)
DimPlot(so2, reduction = "umap")
DimPlot(seurat_obj, reduction = "umap")
ari = adjustedRandIndex(so2$seurat_clusters, seurat_obj$seurat_clusters)
print(ari)
# Subset the expression matrix to include only the genes of interest
keep_genes_idx = which(rownames(seurat_obj@assays$RNA) %in% aryth_genes)
expression_data <- seurat_obj@assays$RNA@layers$counts[keep_genes_idx, ]
# Create a new Seurat object
so_nocycle <- CreateSeuratObject(counts = expression_data)
# Create a new Seurat object
so_nocycle <- CreateSeuratObject(counts = expression_data)
so_nocycle <- NormalizeData(so_nocycle)
so_nocycle <- NormalizeData(so_nocycle)
so_nocycle <- FindVariableFeatures(so_nocycle)
so_nocycle <- ScaleData(so_nocycle)
so_nocycle <- RunPCA(so_nocycle)
# Subset the expression matrix to include only the genes of interest
keep_genes_idx = which(rownames(seurat_obj@assays$RNA) %in% aryth_genes)
expression_data <- seurat_obj@assays$RNA@layers$counts[keep_genes_idx, ]
# Create a new Seurat object
so_nocycle <- CreateSeuratObject(counts = expression_data)
so_nocycle <- NormalizeData(so_nocycle)
so_nocycle <- FindVariableFeatures(so_nocycle)
so_nocycle <- ScaleData(so_nocycle)
so_nocycle <- RunPCA(so_nocycle)
so_nocycle <- FindNeighbors(so_nocycle, dims = 1:30, k.param = 20, compute.SNN = T)
so_nocycle <- FindClusters(so_nocycle, resolution = .3)
# Run UMAP
# so_nocycle <-  RunUMAP(so_nocycle, dims = 1:30, n.neighbors = 30)
seurat_obj$noCyclerClustering = Idents(so_nocycle)
Idents(so_nocycle)
Idents(seurat_obj)
so_nocycle$orig.ident
so_nocycle$seurat_clusters
seurat_obj$noCyclerClustering = unname(unlist(so_nocycle$seurat_clusters))
DimPlot(seurat_obj, reduction = "umap") + ggtitle("With Cycling Genes Clustering")
DimPlot(seurat_obj, reduction = "umap", group.by = "noCyclerClustering") + ggtitle("No Cycling Genes (BH.q < 0.2) Clustering")
ari = adjustedRandIndex(so_nocycle$seurat_clusters, seurat_obj$seurat_clusters)
print(ari)
so2$noCyclerClustering = unname(unlist(so_nocycle$seurat_clusters))
DimPlot(so2, reduction = "umap") + ggtitle("With Cycling Genes Clustering")
DimPlot(so2, reduction = "umap", group.by = "noCyclerClustering") + ggtitle("No Cycling Genes (BH.q < 0.2) Clustering")
ari = adjustedRandIndex(so_nocycle$seurat_clusters, so2$seurat_clusters)
print(ari)
so2 <- RunUMAP(so2)
library(Seurat)
library(tidyverse)
library(deltaccd)
library(edgeR)
library(NMOF)
library(parallel)
library(mclust)
seurat_obj = readRDS("/Users/henryhollis/Downloads/20240529.snTC.integrated.rpca.RDS")
DimPlot(seurat_obj, reduction = "umap", group.by = "seurat_clusters")
hist(seurat_obj$percent.cyc)
aryth = read_csv("GreenhamJTK/GreenhamJTKNonCyclersBHQmoreThan2.csv", show_col_types = F)
aryth_genes = aryth$CycID
so2 = seurat_obj
#Normalization, through RunPCA is saved from seurat_obj, no need
# to recompute them. Greenham uses "reduction = 'integrated.rpca'" for FindNeighbors. This is used when integrating multiple seurat objeccts, which I'm not doing so I will recompute the "findNeighbors." Therefore I don't expect our clustering to be exactly equal.
# so2 <- NormalizeData(so2)
# so2 <- FindVariableFeatures(so2)
# so2 <- ScaleData(so2)
# so2 <- RunPCA(so2,npcs = 30)
so2 <- FindNeighbors(so2, dims = 1:30, k.param = 20, compute.SNN = T)
so2 <- FindClusters(so2, resolution = .3)
# Run UMAP, Seeing if I can recreate Greengham's. Either way cluster assignment is the same.
so2 <- RunUMAP(so2)
so2 <- RunUMAP(so2, dims = 1:30, n.neighbors = 30)
# Plot UMAP
DimPlot(so2, reduction = "umap")
DimPlot(seurat_obj, reduction = "umap")
ari = adjustedRandIndex(so2$seurat_clusters, seurat_obj$seurat_clusters)
print(ari)
# Subset the expression matrix to include only the genes of interest
keep_genes_idx = which(rownames(seurat_obj@assays$RNA) %in% aryth_genes)
expression_data <- seurat_obj@assays$RNA@layers$counts[keep_genes_idx, ]
# Create a new Seurat object
so_nocycle <- CreateSeuratObject(counts = expression_data)
so_nocycle <- NormalizeData(so_nocycle)
so_nocycle <- FindVariableFeatures(so_nocycle)
so_nocycle <- ScaleData(so_nocycle)
so_nocycle <- RunPCA(so_nocycle)
so_nocycle <- FindNeighbors(so_nocycle, dims = 1:30, k.param = 20, compute.SNN = T)
so_nocycle <- FindClusters(so_nocycle, resolution = .3)
# Run UMAP
so_nocycle <-  RunUMAP(so_nocycle, dims = 1:30, n.neighbors = 30)
DimPlot(so_nocycle, reduction = "umap")
so2$noCyclerClustering = unname(unlist(so_nocycle$seurat_clusters))
DimPlot(so2, reduction = "umap") + ggtitle("With Cycling Genes Clustering")
DimPlot(so2, reduction = "umap", group.by = "noCyclerClustering") + ggtitle("No Cycling Genes (BH.q < 0.2) Clustering")
install.packages("ComplexUpset")
# Convert to binary membership matrix
membership_matrix <- table(so2$seurat_clusters, so_nocycle$seurat_clusters)
membership_matrix
upset(data, sets = c('cluster1', 'cluster2'), name='Cluster Comparison')
library(ComplexUpset)
upset(data, sets = c('cluster1', 'cluster2'), name='Cluster Comparison')
data <- data.frame(
cell = paste0("Cell", 1:100),
cluster1 = sample(letters[1:5], 100, replace = TRUE), # First clustering
cluster2 = sample(letters[6:10], 100, replace = TRUE) # Second clustering
)
# Convert to binary membership matrix
membership_matrix <- table(data$cluster1, data$cluster2)
membership_matrix
upset(data, sets = c('cluster1', 'cluster2'), name='Cluster Comparison')
?upset
library(UpSetR)
?upset
upsetR::upset(data, sets = c('cluster1', 'cluster2'), name='Cluster Comparison')
UpsetR::upset(data, sets = c('cluster1', 'cluster2'), name='Cluster Comparison')
UpSetR::upset(data, sets = c('cluster1', 'cluster2'), name='Cluster Comparison')
UpSetR::upset(data, sets = c('cluster1', 'cluster2'))
data
# Convert to binary membership matrix
membership_matrix <- table(so2$seurat_clusters, so_nocycle$seurat_clusters)
membership_matrix
heatmap(membership_matrix)
heatmap(membership_matrix, scale = "none")
membership_df <- as.data.frame(as.table(membership_matrix))
colnames(membership_df) <- c("Cluster1", "Cluster2", "Count")
membership_df
upset(
membership_df,
intersections = list("Cluster1", "Cluster2"),
min_size = 1,
name = "Cluster Comparison"
)
# Convert to binary membership matrix
membership_matrix <- table(so2$seurat_clusters, so_nocycle$seurat_clusters)
# Convert to a data frame suitable for ComplexUpset
membership_df <- as.data.frame(as.table(membership_matrix))
colnames(membership_df) <- c("Cluster1", "Cluster2", "Count")
upset(
membership_df,
intersections = list("Cluster1", "Cluster2"),
min_size = 1,
name = "Cluster Comparison"
)
upset(
membership_df,
intersections = list("Cluster1", "Cluster2"),
)
upset(
membership_df,
intersections = list("Cluster1", "Cluster2")
)
membership_df
ComplexHeatmap::upset(
membership_df,
intersections = list("Cluster1", "Cluster2")
)
ComplexHeatmap::upset(
membership_df,
intersections = list("Cluster1", "Cluster2")
)
ComplexUpset::upset(
membership_df,
intersections = list("Cluster1", "Cluster2")
)
ComplexUpset::upset(
membership_df,
intersections = list("Cluster1", "Cluster2"),
min_size = 1,
name = "Cluster Comparison"
)
ComplexUpset::upset(
membership_df,
intersect = list("Cluster1", "Cluster2"),
min_size = 1,
name = "Cluster Comparison"
)
ComplexUpset::upset(
membership_df,
intersect = list("Cluster1", "Cluster2", "cluster3"),
min_size = 1,
name = "Cluster Comparison"
)
ComplexUpset::upset(
membership_df,
intersect = list("Cluster1", "Cluster2", "Count"),
min_size = 1,
name = "Cluster Comparison"
)
# Convert to a data frame suitable for ComplexUpset
membership_df <- as.data.frame(as.table(membership_matrix))
# Convert to a data frame suitable for ComplexUpset
membership_df <- as.data.frame(as.table(membership_matrix))
View(membership_df)
?upset
DimPlot(so2, reduction = "umap", group.by = "noCyclerClustering") + ggtitle("Remove Cycling Genes (BH.q < 0.2) Clustering")
DimPlot(so2, reduction = "umap") + ggtitle("With Cycling Genes Clustering")
DimPlot(so2, reduction = "umap", group.by = "noCyclerClustering") + ggtitle("Remove Cycling Genes (BH.q < 0.2) Clustering")
DimPlot(so_nocycle, reduction = "umap")
# so2$noCyclerClustering = unname(unlist(so_nocycle$seurat_clusters))
DimPlot(so2, reduction = "umap") + ggtitle("With Cycling Genes Clustering")
DimPlot(so2, reduction = "umap", group.by = "noCyclerClustering") + ggtitle("Remove Cycling Genes (BH.q < 0.2) Clustering")
DimPlot(so_nocycle, reduction = "umap")+ ggtitle("Remove Cycling Genes (BH.q < 0.2) Clustering")
# so2$noCyclerClustering = unname(unlist(so_nocycle$seurat_clusters))
DimPlot(so2, reduction = "umap") + ggtitle("With Cycling Genes Clustering")
DimPlot(so2, reduction = "umap", group.by = "noCyclerClustering") + ggtitle("Remove Cycling Genes (BH.q < 0.2) Clustering")
library(Seurat)
library(edgeR)
library(NMOF)
library(parallel)
library(tidyverse)
library(deltaccd)
library(gridExtra)
library(grid)
load("../rosmap424_pseudobulk_by_cluster.rda")
View(counts)
#creates a seurat object
seurat_obj = CreateSeuratObject( counts,
project = "scRNA ROSMAP",
assay = "RNA",
names.field = 3,
names.delim = "_",
meta.data = pseudobulk_meta)
#get Ribo Protein percent
seurat_obj <- PercentageFeatureSet(seurat_obj, "^RP[SL]", col.name = "percent_ribo")
#Percentage hemoglobin genes - includes all genes starting with HB except HBP.
seurat_obj <- PercentageFeatureSet(seurat_obj, "^HB[^(P)]", col.name = "percent_hb")
#Does number of ribosoal features (%ribo * n_features) change with cogdx
RPSL.genes <- grep(pattern = "^RP[SL]", x = rownames(x = seurat_obj@assays$RNA$counts), value = TRUE)
counts.RPS <- Matrix::colSums(seurat_obj@assays$RNA$counts[RPSL.genes, ])
seurat_obj = AddMetaData( object = seurat_obj, metadata = counts.RPS, col.name = "cnts_ribo" )
seurat_obj_subs = AggregateExpression(seurat_obj,
group.by = c("project_id", "broadclass"),
return.seurat = T
)
setwd("~/Box Sync/Henry_stuff/AD_project/scROSMAP/scrosmap_covariate_fork/scROSMAP_project/Cyclops_ordering/downstream_output_Exc3_5/")
DR = read_csv("diff_rhythms_CyclingBHQ1AmpRatio33.csv")
library("tidyverse")
DM = read_csv("differential_mesor_all_genes.csv")
?contains
DM = read_csv("differential_mesor_all_genes.csv")
View(DM)
DR = grepl(DM$Gene_Symbols, "RP[SL]")
grepl
?grepl
DM$Gene_Symbols
grepl(DM$Gene_Symbols, "RP[SL]")
grepl("RP[SL]",DM$Gene_Symbols)
grepl("RP[SL]|MRP.+|EIF.+",DM$Gene_Symbols)
DM_ribo = filter(DM, grepl("RP[SL]|MRP.+|EIF.+",DM$Gene_Symbols))
View(DM_ribo)
DM_ribo = filter(DM, grepl("RP[SL]|EIF.+",DM$Gene_Symbols))
DM_ribo = filter(DM, grepl("^RP[SL]|EIF.+",DM$Gene_Symbols))
DM_ribo = filter(DM, grepl("^RP[SL]|EIF.+",DM$Gene_Symbols) & BHQ < 0.1)
View(DM_ribo)
DM_ribo %>% mutate(Fold = (mesor_CTL-mesor_AD)/mesor_CTL)
DM_ribo =DM_ribo %>% mutate(Fold = (mesor_CTL-mesor_AD)/mesor_CTL)
DR_ribo = filter(DR, grepl("^RP[SL]|EIF.+",DR$Gene_Symbols) & BHQ < 0.1)
View(DM_ribo)
library("tidyverse")
setwd("~/Box Sync/Henry_stuff/AD_project/scROSMAP/scrosmap_covariate_fork/scROSMAP_project/Cyclops_ordering/downstream_output_Exc3_5/")
DR = read_csv("diff_rhythms_CyclingBHQ1AmpRatio33.csv")
DM = read_csv("differential_mesor_all_genes.csv")
DM_ribo = filter(DM, grepl("^RP[SL]|EIF.+",DM$Gene_Symbols) & BHQ < 0.1)
DM_ribo =DM_ribo %>% mutate(Fold = (mesor_CTL-mesor_AD)/mesor_CTL)
DR_ribo = filter(DR, grepl("^RP[SL]|EIF.+",DR$Gene_Symbols) & BHQ < 0.1)
View(DR_ribo)
grepl("^RP[SL]|EIF.+",DR$Gene_Symbols)''
grepl("^RP[SL]|EIF.+",DR$Gene_Symbols)
DR_ribo = filter(DR, grepl("^RP[SL]|EIF.+",DR$Gene_Symbols))
DR_ribo = filter(DR, grepl("^RP[SL]|EIF.+",DR$Gene_Symbols) & BHQ < 0.2)
test = merge(DM_ribo, DR_ribo, by= "Gene_Symbols", suffixes = c("_DM", "_DR"))
View(test)
DR = read_csv("diff_rhythms_CyclingBHQ1AmpRatio20.csv")
DR_ribo = filter(DR, grepl("^RP[SL]|EIF.+",DR$Gene_Symbols) & BHQ < 0.2)
View(DR)
DR = read_csv("diff_rhythms_CyclingBHQ1AmpRatio33.csv")
View(DR)
DR_ribo = filter(DR, grepl("^RP[SL]|EIF.+",DR$Gene_Symbols) & p_val< 0.05)
View(DR_ribo)
test = merge(DM_ribo, DR_ribo, by= "Gene_Symbols", suffixes = c("_DM", "_DR"))
View(test)
merged = merge(DM_ribo, DR_ribo, by= "Gene_Symbols", suffixes = c("_DM", "_DR")) %>% arrange(Fold)
View(merged)
merged = merge(DM_ribo, DR_ribo, by= "Gene_Symbols", suffixes = c("_DM", "_DR")) %>% arrange(desc(Fold))
View(merged)
write.table(merged$Gene_Symbols, "~/Desktop/Ribo_genes_for_Ashish.csv", sep = ',', row.names = F, col.names = F)
View(DR_ribo)
